---
platform: linux
image_resource:
  type: docker-image
  source:
    #repository: mumoshu/dcind
    repository: amidos/dcind
    #repository: quay.io/cosee-concourse/dind
    tag: latest

inputs:
- name: tm-concourse-pipeline

run:
  path: sh
  args:
  - -exc
  - |
    ci_pipeline_dir=tm-concourse-pipeline

    # copy TM-Concourse-Pipeline into the Docker container
    # Note: the build context is in '${output_dir}' wheras the pipeline is located at ../tm-concourse-pipeline
    cp -R "${ci_pipeline_dir}/" "/tmp/${ci_pipeline_dir}/"

    # To load the `start_docker` function defined in /docker-lib.sh from the docker image `mumoshu/dcind`
    # FIX: error creating aufs mount to /var/lib/docker/aufs/mnt/...: invalid argument (ref: https://github.com/concourse/concourse/issues/1351)
    #sed -i 's/docker daemon/dockerd --data-root \/scratch\/docker/g' /docker-lib.sh
    source /docker-lib.sh
    #start_docker 3 3
    start_docker

    # Print docker/docker-compose information
    docker info
    docker-compose version

    # Strictly speaking, preloading of Docker images is not required.
    # However, you might want to do this for a couple of reasons:
    # - If the image comes from a private repository, it is much easier to let Concourse pull it,
    #   and then pass it through to the task.
    # - When the image is passed to the task, Concourse can often get the image from its cache.
    cd "/tmp/${ci_pipeline_dir}/integration-test-tasks/fixtures"
    docker-compose pull

    docker images

    # Start test environment
    docker-compose ps
    docker-compose run --rm tm_client ls -ahl /var/lib/pgsql/
    docker-compose run --rm tm_client ls -ahl /var/lib/pgsql-9.6/citus-6.2/master
    docker-compose run --rm tm_client ls -ahl /var/lib/pgsql-9.6/citus-6.2/master/pg_log
    docker-compose up -d tm_database
    docker-compose ps
    function dbIsReady() {
        cat $(docker inspect --format='{{.LogPath}}' $(docker-compose ps -q tm_database))
        #docker-compose logs tm_database 2>&1
        docker-compose logs tm_database | grep "PostgreSQL init process complete"
    }
    until dbIsReady;
    do
        echo "Waiting for PostgreSQL..."
        sleep 1
    done

    docker-compose up -d tm_server
    until [ "$(docker inspect -f {{.State.Running}} $(docker-compose ps -q tm_server))"=="true" ]; do
        sleep 1;
    done;

    #docker-compose up -d tm_client
    #until [ "$(docker inspect -f {{.State.Running}} $(docker-compose ps -q tm_client))"=="true" ]; do
    #    sleep 1;
    #done;

    #docker logs --tail 50 --follow --timestamps mediawiki_web_1
    #docker logs --tail 50 --timestamps tmclient
    docker-compose logs tm_database
    docker-compose logs tm_server
    #docker-compose logs tm_client
    #docker-compose logs

    # Run tests
    #docker exec -t tmclient protractor test/protractor.conf.js
    docker-compose run --rm tm_client protractor test/protractor.conf.js

    # Teardown test environment
    rc=$?
    docker-compose down
    echo "exit code = $rc "
    kill %1
    exit $rc
